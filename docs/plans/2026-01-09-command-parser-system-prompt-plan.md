# LLM 指令解析 System Prompt 改造计划（多命令 + 槽位升华）

## 背景

当前大模型主要做“字符串切分”，输出类似“打开-卧室-顶灯”。这在单命令场景可用，但在以下情况会明显不足：

- **多命令**：一句话包含多个动作/多个目标时，无法稳定拆分为可执行的原子命令。
- **语义升华**：只做分割缺少对 **type（闭集类别）**、**量词**、**数量（量词/数词）**、**指代（它/那个/上一个）** 的结构化理解与填充。
- **输出不应复杂化**：需要保持对现有三段式解析逻辑友好，同时让语义信息“可解析、可验证、可扩展”。

本计划将输出协议升级为：**保留单条命令的三段式字符串结构**，并用最小的二级分隔把语义槽位落到 `TARGET` 中；多命令则用 **JSON 数组**承载，避免引入更复杂的对象结构。

## 目标

- 输出仍然兼容单条三段式：`ACTION-SCOPE-TARGET`。
- 大模型负责：**语义理解 → 原子化拆分 → 槽位填充**（type/量词/数量/指代）。
- 输出结构最小化：整体是 `JSON array<string>`，每条命令仍是一个字符串。
- `action` 尽量“**一个动作只做一件事**”（同设备多步骤必须拆分成多条命令）。
- `type` 来自闭集（当前为 12 个类型），无法判断填 `Unknown`。
- 默认语义：当用户 **按类型泛指**（没有点名具体设备名）时，量词默认视为 `all`。

## 非目标

- 不在输出中引入更复杂的嵌套 JSON 对象（除非后续确有必要）。
- 不引入超大同义词词典/规则引擎（优先由 LLM 在 prompt 约束下直接输出 canonical 结果）。
- 不在本阶段定义设备消歧、执行编排、权限校验等业务逻辑（这些属于消费侧实现）。

## 输出协议（Contract）

### 总体输出

- 输出必须是 **JSON 数组**：`[...]`
- 数组元素是 **命令字符串**；即使只有一条命令也必须输出数组。
- 不得输出任何额外文本（无解释、无 Markdown、无代码块、无前后缀）。

### 单条命令语法

- 命令字符串格式：`ACTION-SCOPE-TARGET`
- `TARGET` 二级结构：`NAME#TYPE#Q[#N]`

字段定义如下：

#### ACTION（原子动作）

- 必须为中文意图短语，且不得包含分隔符 `-`。
- 倾向于原子化表达（一个 action 做一件事），例如：
  - 打开 / 关闭
  - 查询状态
  - 设置亮度=50%
  - 设置温度=26C
- 如果原句出现多个动作（即使针对同一设备），必须拆分为多条命令，分别输出。

#### SCOPE（房间/区域）

- 未提及房间：`*`
- 多房间：用英文逗号分隔，例如：客厅,卧室
- 排除房间：用 `!` 前缀，可多个，例如：*,!卧室,!书房
- 约定：若 SCOPE 只包含排除项（例如 !卧室），消费侧解析时可视为隐含包含 `*`。

#### TARGET（目标槽位升华）

`TARGET = NAME#TYPE#Q[#N]`

- NAME
  - 点名设备：输出设备名（如 顶灯、老伙计）
  - 仅按类型泛指（如“灯/空调/风扇/窗帘”且无具体名称）：输出 `*`
  - 指代（它/那个/上一个/刚才的）：输出 `@last`
  - 约束：不得包含 `#` 或 `-`（遇到则用空格替换）
- TYPE（闭集类型，必须输出）
  - 必须且只能为以下之一：`AirConditioner, Blind, Charger, Fan, Hub, Light, NetworkAudio, Switch, Television, Washer, SmartPlug, Unknown`
  - 无法判断时输出 `Unknown`
- Q（量词，必须输出）
  - 取值只能是：`one | all | any | except`
  - 映射规则：
    - 所有/全部/都/每个 → `all`
    - 任意/随便/哪个都行/几个 → `any`
    - 除了X以外/除X都 → `except`（配合 SCOPE 的 `!` 表达排除）
    - 其他情况 → `one`
  - 默认规则（已确认）：当 `NAME="*"` 且用户未明确量词时，`Q` 默认输出 `all`
- N（数量，可选）
  - 仅当用户明确数量时输出整数（例如 “两/俩/2” → `2`）
  - 建议与 `Q=any` 搭配表达“任意 N 个”（例如“打开两盏灯”→ `any + N=2`）

### 拆分规则（多命令）

必须按“原子可执行命令”拆分，连接词只是提示，不是唯一条件：

- 多动作：同一目标多个动作（如“打开并调到50%”）→ 拆成多条命令。
- 多目标：同一动作作用于多个设备（和/以及/、/逗号列举等）→ 每个目标一条命令。
- 多步骤：一句话包含“先…再…”或类似顺序 → 按顺序拆分输出。

### 兼容性约定

- 仍兼容旧的三段式解析：消费侧可先按 `-` 切分三段得到 `ACTION/SCOPE/TARGET`。
- 新增语义只在 `TARGET` 中用 `#` 承载；旧逻辑若忽略 `#` 后缀，仍可拿到主要 `NAME`（需要消费侧决定是否截断）。
- 若消费侧暂不支持多命令数组，可先只取数组第 1 条命令作为降级策略（但会丢失后续命令）。

## System Prompt（最终版，直接可用）

> 你是智能家居指令的语义解析器。你的输出会被程序解析，因此必须严格遵守格式：只输出严格 JSON，不输出任何额外文本。
>
> 输出必须是一个 JSON 数组，数组元素是命令字符串；即使只有一条命令也必须用数组包装。
>
> 每条命令字符串格式：ACTION-SCOPE-TARGET
>
> 1) ACTION（原子动作）
> - ACTION 必须是“一个动作尽量只做一件事”，不得包含字符“-”。
> - 例：打开、关闭、查询状态、设置亮度=50%、设置温度=26C。
> - 若一句话包含多个动作（即使针对同一设备，如“打开并调到50%”），必须拆成多条命令分别输出。
>
> 2) SCOPE（房间/区域）
> - 未提及输出 *。
> - 提及多个房间用英文逗号 ,：如 客厅,卧室。
> - 排除房间用 !房间（可多个）：如 *,!卧室,!书房。若只输出 !卧室 也允许，表示默认包含所有房间再排除卧室。
>
> 3) TARGET（语义升华槽位）
> - TARGET 必须为：NAME#TYPE#Q[#N]
>   - NAME：设备名；若用户仅按类型泛指（如“灯/空调/风扇/窗帘”而非具体名称）输出 *；指代“它/那个/上一个/刚才的”输出 @last。NAME 不得包含 # 或 -（遇到则用空格替换）。
>   - TYPE：必须且只能从闭集选择（无法判断用 Unknown）：
>     AirConditioner, Blind, Charger, Fan, Hub, Light, NetworkAudio, Switch, Television, Washer, SmartPlug, Unknown
>   - Q：量词，必须为 one/all/any/except
>     - 所有/全部/都/每个 → all
>     - 任意/随便/哪个都行/几个 → any
>     - 除了X以外/除X都 → except
>     - 否则 → one
>     - 重要默认：当 NAME=*（泛指类型）且未明确量词时，Q 默认输出 all
>   - N：仅当用户明确数量时输出整数（两/俩/2→2），否则不输出该段。
>
> 拆分规则（必须遵守）
> - 多动作必拆分；多目标（列举多个设备名）必拆分为多条命令；按原句顺序输出。
>
> 无法解析时输出：["UNKNOWN-*-*#Unknown#one"]

## 实现侧解析与校验（建议）

消费侧建议实现一个“严格但可降级”的解析器：

1. **严格 JSON 解析**：优先直接 `json.loads(...)` 解析数组字符串。
2. **逐条解析命令字符串**：
   - 按第一个层级分隔符 `-` 切出三段：`ACTION/SCOPE/TARGET`（不满足则判为无效命令）。
   - `SCOPE` 按 `,` 切分；`!` 前缀归入 exclude；其余归入 include；若 include 为空则视为 include=`*`。
   - `TARGET` 按 `#` 切分：
     - 至少应存在 `NAME#TYPE#Q` 三段；否则无效。
     - 校验 `TYPE` 是否在闭集；否则改为 `Unknown`。
     - 校验 `Q` 是否在 `one/all/any/except`；否则改为 `one`。
     - `N` 若存在必须为整数；否则丢弃。
3. **错误处理**：
   - 若数组为空或解析失败：统一降级为 `UNKNOWN-*-*#Unknown#one`。
   - 解析到部分无效命令时：保留有效命令；若全部无效则降级为 `UNKNOWN...`。
4. **可观测性**：记录原始 LLM 输出、解析错误原因（不要只记录“失败”）。

## 验收标准（Acceptance Criteria）

### 协议层

- 输出始终是合法 JSON 数组。
- 每条命令满足三段式且 TARGET 至少包含 `NAME#TYPE#Q`。
- `TYPE` 永远落在闭集（否则必须被修正为 `Unknown`）。
- 当用户泛指类型且未说明量词时，输出 `Q=all`（已确认）。
- 一句多动作必须拆成多条命令，且 `ACTION` 保持原子化。

### 示例用例（期望形态）

| 用户输入 | 期望输出（示例） |
| --- | --- |
| 打开卧室的顶灯 | ["打开-卧室-顶灯#Light#one"] |
| 打开客厅的灯 | ["打开-客厅-*#Light#all"] |
| 打开卧室顶灯调到50% | ["打开-卧室-顶灯#Light#one", "设置亮度=50%-卧室-顶灯#Light#one"] |
| 打开卧室顶灯然后关闭客厅灯 | ["打开-卧室-顶灯#Light#one", "关闭-客厅-*#Light#all"] |
| 打开除卧室以外的灯 | ["打开-*,!卧室-*#Light#except"] |
| 打开它 | ["打开-*-@last#Unknown#one"] |

## 落地步骤（实施清单）

1. 将上述 System Prompt 作为解析器的 system prompt 固化到配置/常量，并在调用侧强制使用。
2. 在消费侧实现解析器（按协议拆分并产出内部结构），并补齐日志与降级策略。
3. 以“示例用例”为起点补齐单元测试；覆盖多动作、多目标、except、any+N、@last、UNKNOWN。
4. 灰度上线：保留旧路径/旧解析兼容开关；收集解析失败率与 UNKNOWN 比例，迭代 prompt 细节。
