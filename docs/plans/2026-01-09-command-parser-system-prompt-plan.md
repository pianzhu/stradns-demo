# LLM 指令解析 System Prompt 改造计划（多命令 + 槽位升华）

## 背景

当前大模型主要做“字符串切分”，输出类似“打开-卧室-顶灯”。这在单命令场景可用，但在以下情况会明显不足：

- **多命令**：一句话包含多个动作/多个目标时，无法稳定拆分为可执行的原子命令。
- **语义升华**：只做分割缺少对 **type（闭集类别）**、**量词**、**数量（量词/数词）**、**指代（它/那个/上一个）** 的结构化理解与填充。
- **输出不应复杂化**：需要保持对现有三段式解析逻辑友好，同时让语义信息“可解析、可验证、可扩展”。

本计划将输出协议升级为：**输出 JSON 对象数组**，用最小字段集 `a/s/n/t/q/c` 承载语义槽位；消费侧如需复用旧解析逻辑，可将对象转换为 `ACTION-SCOPE-TARGET` 三段式字符串。

## 目标

- 输出为 `JSON array<object>`，数组元素为命令对象。
- 兼容旧三段式：消费侧可将对象桥接为 `ACTION-SCOPE-TARGET`。
- 大模型负责：**语义理解 → 原子化拆分 → 槽位填充**（type/量词/数量/指代）。
- 输出结构最小化：对象字段仅包含 `a/s/n/t/q/c`。
- `action` 尽量“**一个动作只做一件事**”（同设备多步骤必须拆分成多条命令）。
- `type` 来自闭集（当前为 12 个类型），无法判断填 `Unknown`。
- 默认语义：当用户 **按类型泛指**（没有点名具体设备名）时，量词默认视为 `all`。

## 非目标

- 不引入更复杂的嵌套对象结构（例如 target 子对象）。
- 不引入超大同义词词典/规则引擎（优先由 LLM 在 prompt 约束下直接输出 canonical 结果）。
- 不在本阶段定义设备消歧、执行编排、权限校验等业务逻辑（这些属于消费侧实现）。

## 输出协议（Contract）

### 总体输出

- 输出必须是 **JSON 数组**：`[...]`
- 数组元素是 **命令对象**；即使只有一条命令也必须输出数组。
- 不得输出任何额外文本（无解释、无 Markdown、无代码块、无前后缀）。

### 命令对象字段

- `a`: 动作（中文意图短语）
- `s`: 房间/区域字符串（支持 `*`、`,`、`!`）
- `n`: 设备名（或类型中文名/`@last`）
- `t`: 类型（闭集）
- `q`: 量词（one/all/any/except）
- `c`: 数量（仅明确数量时输出整数）

字段定义如下：

#### a（原子动作）

- 必须为中文意图短语，且不得包含分隔符 `-`。
- 倾向于原子化表达（一个动作只做一件事），例如：
  - 打开 / 关闭
  - 查询状态
  - 设置亮度=50%
  - 设置温度=26C
- 如果原句出现多个动作（即使针对同一设备），必须拆分为多条命令，分别输出。

#### s（房间/区域）

- 未提及房间：`*`
- 多房间：用英文逗号分隔，例如：客厅,卧室
- 排除房间：用 `!` 前缀，可多个，例如：*,!卧室,!书房
- 约定：若仅包含排除项（例如 !卧室），消费侧可视为隐含包含 `*`。

#### n（设备名）

- 点名设备：输出设备名（如 顶灯、老伙计）
- 仅按类型泛指（如“灯/空调/风扇/窗帘”等且无具体名称）：输出类型中文名（不要输出 `*`），并与 `t` 一致（如 `Light→灯`、`AirConditioner→空调`、`Blind→窗帘`）
- 指代（它/那个/上一个/刚才的）：输出 `@last`
- 约束：不得包含 `#` 或 `-`（遇到则用空格替换）

#### t（类型）

- 必须且只能为以下之一：`AirConditioner, Blind, Charger, Fan, Hub, Light, NetworkAudio, Switch, Television, Washer, SmartPlug, Unknown`
- 无法判断时输出 `Unknown`

#### q（量词）

- 取值只能是：`one | all | any | except`
- 映射规则：
  - 所有/全部/都/每个 → `all`
  - 任意/随便/哪个都行/几个 → `any`
  - 除了X以外/除X都 → `except`（配合 `s` 的 `!` 表达排除）
  - 其他情况 → `one`
- 默认规则：当用户按类型泛指且未明确量词时，`q` 默认输出 `all`

#### c（数量，可选）

- 仅当用户明确数量时输出整数（例如 “两/俩/2” → `2`）
- 建议与 `q=any` 搭配表达“任意 N 个”（例如“打开两盏灯”→ `any + c=2`）

### 拆分规则（多命令）

必须按“原子可执行命令”拆分，连接词只是提示，不是唯一条件：

- 多动作：同一目标多个动作（如“打开并调到50%”）→ 拆成多条命令。
- 多目标：同一动作作用于多个设备（和/以及/、/逗号列举等）→ 每个目标一条命令。
- 多步骤：一句话包含“先…再…”或类似顺序 → 按顺序拆分输出。

### 兼容性约定

- 兼容旧三段式解析：消费侧可将对象转换为 `ACTION-SCOPE-TARGET`，其中 `TARGET = n#t#q[#c]`。
- 若消费侧暂不支持对象数组，可先只取数组第 1 条命令作为降级策略（但会丢失后续命令）。

## System Prompt（最终版，直接可用）

> 你是智能家居指令解析器。只输出 JSON 数组，不要解释、不要代码块、不要多余文本。
> 输出尽量紧凑：不要换行，字段间不需要空格。
>
> 数组元素为对象，只允许字段（按顺序输出）：a,s,n,t,q,c
> a：动作（中文）。打开/关闭；设置用"设置<属性>=<值>"；查询用"查询<属性>"；静音/取消静音。
> s：房间。未知"*"；多房间用","分隔；排除房间用"!"前缀（例"*,!卧室"）。
> n：设备名（去掉房间词，保留修饰词）。指代词用"@last"；不确定用"*"。
> t：类型，仅限 AirConditioner/Blind/Charger/Fan/Hub/Light/NetworkAudio/Switch/Television/Washer/SmartPlug/Unknown；不确定用"Unknown"。
> q：one|all|any|except。泛指类型默认 all；不确定用 one。
> c：仅明确数量时为整数；否则不要输出该字段。
>
> 多动作/多目标：拆成多个对象，按语序输出；每个对象只含一个动作 + 一个目标。
> 泛指类型（如“所有灯”“三个插座”）：n 填该类型的中文原文（如“灯”“插座”“空调”“窗帘”），不要用"*"
>
> 完全无法解析时输出：[{"a":"UNKNOWN","s":"*","n":"*","t":"Unknown","q":"one"}]

## 实现侧解析与校验（建议）

消费侧建议实现一个“严格但可降级”的解析器：

1. **严格 JSON 解析**：优先直接 `json.loads(...)` 解析数组字符串。
2. **逐条解析命令对象**：
   - 支持 `array<object>` 与 `array<string>`；对象格式优先。
   - 对象字段 `a/s/n/t/q/c` 做默认值补齐与合法性校验。
   - 如需复用旧解析逻辑，可将对象转换为 `ACTION-SCOPE-TARGET`（其中 `TARGET = n#t#q[#c]`）。
3. **错误处理**：
   - 若数组为空或解析失败：统一降级为 `{"a":"UNKNOWN","s":"*","n":"*","t":"Unknown","q":"one"}`。
   - 解析到部分无效命令时：保留有效命令；若全部无效则降级为 `UNKNOWN...`。
4. **可观测性**：记录原始 LLM 输出、解析错误原因（不要只记录“失败”）。

## 验收标准（Acceptance Criteria）

### 协议层

- 输出始终是合法 JSON 数组。
- 每条命令对象必须包含 `a/s/n/t/q`，可选 `c`。
- `t` 永远落在闭集（否则必须被修正为 `Unknown`）。
- 当用户泛指类型且未说明量词时，输出 `q=all`。
- 一句多动作必须拆成多条命令，且 `a` 保持原子化。

### 示例用例（期望形态）

| 用户输入 | 期望输出（示例） |
| --- | --- |
| 打开卧室的顶灯 | [{"a":"打开","s":"卧室","n":"顶灯","t":"Light","q":"one"}] |
| 打开客厅的灯 | [{"a":"打开","s":"客厅","n":"灯","t":"Light","q":"all"}] |
| 打开卧室顶灯调到50% | [{"a":"打开","s":"卧室","n":"顶灯","t":"Light","q":"one"},{"a":"设置亮度=50%","s":"卧室","n":"顶灯","t":"Light","q":"one"}] |
| 打开卧室顶灯然后关闭客厅灯 | [{"a":"打开","s":"卧室","n":"顶灯","t":"Light","q":"one"},{"a":"关闭","s":"客厅","n":"灯","t":"Light","q":"all"}] |
| 打开除卧室以外的灯 | [{"a":"打开","s":"*,!卧室","n":"灯","t":"Light","q":"except"}] |
| 打开它 | [{"a":"打开","s":"*","n":"@last","t":"Unknown","q":"one"}] |

## 落地步骤（实施清单）

1. 将上述 System Prompt 作为解析器的 system prompt 固化到配置/常量，并在调用侧强制使用。
2. 在消费侧实现解析器（按协议拆分并产出内部结构），并补齐日志与降级策略。
3. 以“示例用例”为起点补齐单元测试；覆盖多动作、多目标、except、any+N、@last、UNKNOWN。
4. 灰度上线：保留旧路径/旧解析兼容开关；收集解析失败率与 UNKNOWN 比例，迭代 prompt 细节。
