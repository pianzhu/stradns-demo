## 上下文

本变更聚焦“指令解析（Command Parser）”的输出协议与 system prompt：输出为 JSON 对象数组，支持一句话多命令拆分，并把 type/量词/数量/指代等语义以最小结构化方式落到 `a/s/n/t/q/c` 字段中，消费侧可桥接为三段式字符串以复用旧解析逻辑。

## 目标 / 非目标

- 目标：
  - 兼容旧解析：消费侧可桥接为 `ACTION-SCOPE-TARGET`
  - 支持多命令：整体输出为 `JSON array<object>`，按原句顺序输出原子命令
  - 槽位升华最小化：对象字段 `a/s/n/t/q/c`
  - 可验证：消费侧可以做确定性校验与降级，避免“看起来像但不可执行”的输出
- 非目标：
  - 不引入更复杂的嵌套对象结构（例如 target 子对象）
  - 不在本阶段定义设备消歧、执行编排、权限/安全策略等业务逻辑

## 决策

- 决策：整体输出为 `JSON array<object>`，数组元素为命令对象
  - 原因：对象字段表达更直接，减少二次解析歧义，并仍可在消费侧桥接为字符串。
- 决策：字段使用 `a/s/n/t/q/c`
  - 原因：字段数量固定且语义清晰，兼顾可读性与成本。
- 决策：消费侧允许桥接为 `ACTION-SCOPE-TARGET`
  - 原因：保持与既有解析器兼容，降低迁移成本。
- 决策：TYPE 使用闭集，无法判断输出 `Unknown`
  - 原因：闭集类型便于消费侧做强校验与映射；并可复用既有类型集合，降低漂移风险。
- 决策：当用户“按类型泛指”且未明确量词时，`n` 输出类型中文名（不要输出 `*`），且 `q` 默认输出 `all`
  - 原因：减少小模型对“通配符边界”的判断负担；同时保持输出自然语言可读，消费侧仍可用 `t+q` 做确定性解释。

## 考虑的替代方案

- 方案 A：`JSON array<string>`（三段式字符串）
  - 优点：最少变更，复用现有解析
  - 缺点：多层分隔易出错，可验证性弱
- 方案 B：仍输出单条字符串，使用换行或分号表示多命令
  - 优点：最少变更
  - 缺点：解析不够稳健（转义/噪声），且无法强制“即使一条也统一形态”
- 方案 C：输出 YAML
  - 优点：可读性强
  - 缺点：与“严格 JSON”约束冲突，且解析/容错成本更高

## 风险 / 权衡

- 分隔符注入：设备名/房间名可能包含 `-` 或 `#` 导致解析歧义
  - 缓解：在协议中明确 n 不得包含 `#` 或 `-`，遇到则替换为空格；a 不得包含 `-`
- 输出不合规：LLM 可能输出额外文本或非 JSON
  - 缓解：消费侧必须做严格 JSON 解析；失败统一降级为 `UNKNOWN`，并记录错误原因用于观测
- 语义冗余：`q=except` 与 `s` 的 `!` 排除可能重复表达
  - 缓解：保留冗余以提升可解释性；消费侧以确定性规则归一化（如 include 为空则隐式 `*`）

## 迁移计划

- 第 1 阶段：消费侧实现“严格但可降级”的解析与校验（支持旧单条字符串输入与新数组输出的兼容入口）
- 第 2 阶段：切换 system prompt 为新协议，并灰度观察解析失败率与 `UNKNOWN` 比例
- 第 3 阶段：移除旧协议入口（如需要），并将非合规输出统一视为错误/降级

## 待决问题

- `q=except` 是否必须与 `s` 的排除项同时出现，还是允许仅用其中一种表达？
- 当用户给出数量但目标是“点名具体设备”（n 为具体设备名而非类型词）时，是否应忽略 c 还是输出并由消费侧报错？
