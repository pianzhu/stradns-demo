## 上下文

本变更聚焦“指令解析（Command Parser）”的输出协议与 system prompt：在保持三段式 `ACTION-SCOPE-TARGET` 兼容性的前提下，支持一句话多命令拆分，并把 type/量词/数量/指代等语义以最小结构化方式落到 `TARGET` 中，便于消费侧解析、校验与降级。

## 目标 / 非目标

- 目标：
  - 兼容三段式主结构：每条命令仍是单个字符串 `ACTION-SCOPE-TARGET`
  - 支持多命令：整体输出为 `JSON array<string>`，按原句顺序输出原子命令
  - 槽位升华最小化：`TARGET` 采用 `NAME#TYPE#Q[#N]`
  - 可验证：消费侧可以做确定性校验与降级，避免“看起来像但不可执行”的输出
- 非目标：
  - 不引入每条命令的嵌套 JSON object（除非后续证明确有必要）
  - 不在本阶段定义设备消歧、执行编排、权限/安全策略等业务逻辑

## 决策

- 决策：整体输出为 `JSON array<string>`，数组元素为命令字符串
  - 原因：多命令是第一优先级缺口；数组在结构上最小且可直接做严格 JSON 解析；同时仍允许消费侧短期降级只取第 1 条。
- 决策：保持三段式 `ACTION-SCOPE-TARGET`
  - 原因：消费侧若已有三段式解析器，可复用 `split('-', 2)` 的逻辑；本变更仅在 `TARGET` 内新增 `#` 的二级槽位分隔。
- 决策：`TARGET = NAME#TYPE#Q[#N]`
  - 原因：在不引入对象结构的前提下，最小承载关键语义（类型闭集、量词、数量）；对 NAME 仍友好（忽略 `#` 后缀也可拿到主要目标）。
- 决策：TYPE 使用闭集，无法判断输出 `Unknown`
  - 原因：闭集类型便于消费侧做强校验与映射；并可复用既有类型集合，降低漂移风险。
- 决策：当用户“按类型泛指”且未明确量词时，`NAME="*"` 且 `Q` 默认输出 `all`
  - 原因：减少消费侧补默认逻辑，符合用户对“打开灯”的常见预期。

## 考虑的替代方案

- 方案 A：`JSON array<object>`（每条命令为 `{action, scope, target:{...}}`）
  - 优点：结构最清晰，扩展性最好
  - 缺点：对消费侧侵入更大、prompt token 更高、与“保持旧三段式友好”目标冲突
- 方案 B：仍输出单条字符串，使用换行或分号表示多命令
  - 优点：最少变更
  - 缺点：解析不够稳健（转义/噪声），且无法强制“即使一条也统一形态”
- 方案 C：输出 YAML
  - 优点：可读性强
  - 缺点：与“严格 JSON”约束冲突，且解析/容错成本更高

## 风险 / 权衡

- 分隔符注入：设备名/房间名可能包含 `-` 或 `#` 导致解析歧义
  - 缓解：在协议中明确 NAME 不得包含 `#` 或 `-`，遇到则替换为空格；ACTION 不得包含 `-`
- 输出不合规：LLM 可能输出额外文本或非 JSON
  - 缓解：消费侧必须做严格 JSON 解析；失败统一降级为 `UNKNOWN`，并记录错误原因用于观测
- 语义冗余：`Q=except` 与 `SCOPE` 的 `!` 排除可能重复表达
  - 缓解：保留冗余以提升可解释性；消费侧以确定性规则归一化（如 include 为空则隐式 `*`）

## 迁移计划

- 第 1 阶段：消费侧实现“严格但可降级”的解析与校验（支持旧单条字符串输入与新数组输出的兼容入口）
- 第 2 阶段：切换 system prompt 为新协议，并灰度观察解析失败率与 `UNKNOWN` 比例
- 第 3 阶段：移除旧协议入口（如需要），并将非合规输出统一视为错误/降级

## 待决问题

- `Q=except` 是否必须与 `SCOPE` 的排除项同时出现，还是允许仅用其中一种表达？
- 当用户给出数量但目标是“点名设备”（NAME 非 `*`）时，是否应忽略 N 还是输出并由消费侧报错？

